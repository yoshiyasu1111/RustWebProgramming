## アプリケーションを構成する

今、私たちはデータベースのURLを.envファイルに保存しています。これでもいいのですが、yamlの設定ファイルを使うこともできます。Webサーバを開発する場合、異なる環境で実行されることになります。例えば、今はRustサーバをローカルマシンで動かしています。しかし、後でサーバーを独自のDockerイメージにパッケージして、クラウド上にデプロイする予定です。マイクロサービスインフラでは、あるクラスタで構築したサーバを、接続するデータベースが異なる別のクラスタで利用することもあります。そのため、内向きのトラフィックと外向きのトラフィックを定義する設定ファイルが不可欠になります。サーバーをデプロイする際に、AWS S3などのファイルストレージにリクエストして、そのサーバーに適した設定ファイルを取得することができます。なお、環境変数はコンテナに渡すことができるため、デプロイ時に優先的に使用することができます。環境変数を使用してWebアプリケーションを構成する方法については、第13章「クリーンなWebアプリケーションリポジトリのためのベストプラクティス」で説明します。今のところ、設定ファイルを使用することに焦点を当てます。また、どの設定ファイルを読み込むかという点で、サーバーが柔軟に対応できるようにする必要があります。たとえば、特定のディレクトリにある特定の名前の設定ファイルをサーバーに読み込ませる必要はありません。間違った設定ファイルがサーバーに読み込まれるリスクを減らすために、設定ファイルには適切なコンテキストに応じた適切な名前を付けておく必要があります。ファイルへのパスは、サーバーをスピンアップするときに渡すことができます。ここでは yaml ファイルを使用しているため、Cargo.toml ファイルに serde_yaml 依存関係を以下のように定義する必要があります。

```toml
serde_yaml = "0.8.23"
```

yamlファイルを読めるようになったので、yamlファイルの値をHashMapにロードする独自の設定モジュールを作ることができます。これは1つの構造体で実現できるので、configモジュールを1つのファイル（src/config.rsファイル）にまとめることにします。まず、以下のコードで必要なものをインポートします。

```rust
use std::collections::HashMap;
use std::env;
use serde_yaml;
```

このコードでは、envを使用してプログラムに渡される環境変数を取得し、HashMapを使用して設定ファイルのデータを格納し、serde_yaml crateを使用して設定ファイルからyaml値を処理しています。次に、設定データを格納する構造体を、以下のコードで定義します。

```rust
pub struct Config {
    pub map: HashMap<String, serde_yaml::Value>
}
```

先ほどのコードでは、値のデータキーがStringで、そのキーに属する値がyaml値であることがわかります。次に、プログラムに渡された最後の引数を受け取る構造体のコンストラクタを作成し、プログラムに渡されたファイルへのパスに基づいてファイルを開き、次のコードでファイルからデータをマップ フィールドにロードします。

```rust
impl Config {
    pub fn new() -> Config {
        let args: Vec<String> = env::args().collect();
        let file_path = &args[args.len() - 1];
        let file = std::fs::File::open(file_path).unwrap();
        let map: HashMap<String, serde_yaml::Value> = 
            serde_yaml::from_reader(file).unwrap();
        return Config{map}
    }
}
```

config構造体が定義されたので、src/main.rsファイルに次のようなコードでconfigモジュールを定義することができます。

```rust
mod config;
```

次に、src/database.rsファイルをリファクタリングして、yaml設定ファイルからロードする必要があります。リファクタリングされたインポートは次のような形になっています。

```rust
use diesel::prelude::*;
use diesel::pg::PgConnection;
use crate::config::Config;
```

envへの参照はすべて削除され、configモジュールで処理されていることがわかります。次に、ファイルを読み込み、DB_URLキーを取得し、DB_URLキーに関連する変数を取得し、yaml値を文字列に変換し、その変換結果を直接アンラップしています。取得と変換の関数を直接アンラップするのは、これらの関数が失敗すると、いずれにしてもデータベースに接続できなくなるからです。接続できない場合、どこで何が起こっているのかを示す明確なエラーメッセージとともに、できるだけ早くそのエラーを知りたいのです。これで、Rustアプリケーションのルートにあるconfig.ymlファイルに、次のような内容でデータベースのURLを記述することができるようになりました。

```yaml
DB_URL: postgres://username:password@localhost:5433/to_do
```

次に、以下のコマンドでアプリケーションを実行します。

```bash
$ cargo run config.yml
```

config.ymlファイルは、設定ファイルへのパスです。docker-composeとfrontendを実行すると、configファイルからデータベースのURLが読み込まれ、アプリケーションがデータベースに接続されていることが確認できます。しかし、このデータベース接続には1つ問題があります。establish_connection関数を実行するたびに、データベースへの接続が行われます。これは動作しますが、しかし、最適ではありません。次のセクションでは、データベース接続プーリングを使用して、データベース接続をより効率的に行う方法を説明します。
